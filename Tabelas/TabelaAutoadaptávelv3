let
    // Carrega o ficheiro Excel a partir do diretório parametrizado na variável varCaminho
    // O uso de 'true' no terceiro argumento permite a importação com cabeçalhos automáticos
    fonte = Excel.Workbook(
        File.Contents(varCaminho & "\Rendimentos.xlsx"), // Le o arquivo no caminho informado e converte em binário
        null, // Essa etapa tenta advinhar e promover os cabeçalhos do arquivo. O null como resposta está dizendo pra ignorar essa tentativa
        true // True informa que NÃO queremos que o Power Query tente adivinhar o tipo de dado automaticamente
    ),

    filtraLinhas = Table.SelectRows( // Seleciona as linhas da tabela
        fonte, // Etapa anterior
        each // Percorre cada uma das linhas
            [Kind] = "Table" and [Item] = "Rendimentos" // Retona apenas a linha que atende as condições
    ),


    listaColunasDinamicas = List.Distinct( // Cria uma lista distinguindo o nome das colunas para evitar duplicados e travar o código
        List.Combine( // Combina o resultado gerando uma lista com o nome de todas as colunas (Assim premeditamos até a união de multiplos arquivos)
            List.Transform( // Vai percorrer cada uma das linhas dentro da coluna Data para capturarmos o nome das colunas
                filtraLinhas[Data], // Procura o nome das colunas que vamos extrair dentro do Data antes de expandir os dados
                each Table.ColumnNames(_) // Identifica o nome de cada uma das colunas
            )
        )
    ),

    dadosExpandidos = Table.ExpandTableColumn(
        filtraLinhas, // Etapa anterior
        "Data", // Nome da coluna que contém as tabelas (nomes das colunas que vamos identificar automaticamente e expandir) 
        listaColunasDinamicas, // Nome das colunas que queremos extrair da coluna Data
        listaColunasDinamicas // Como queremos nomear cada uma das novas colunas (Vai ser o padrão Column1, Column2, etc..)
    ),

    // Em vez de remover o que você não quer, você seleciona apenas o que você quer
    manterApenasColunasDinamicas = Table.SelectColumns( // Seleciona as colunas
        dadosExpandidos, // Etapa anterior 
        listaColunasDinamicas, // Nome das colunas que devem ser mantidas, ou seja, colunas do arquivo original
        MissingField.Ignore // Se uma das colunas desaparecer não vai travar o código
    ),

    // Aidicona uma coluna para identificarmos quais linhas só tem valores nulos ou vazios
    adicionaColunaTemporariaParaOrdenarVazios = Table.AddColumn( // Adiciona uma nova coluna
        manterApenasColunasDinamicas, // Etapa anterior
        "Linha Vazia", // Nome da nova coluna temporária
        each 
            if List.NonNullCount(Record.FieldValues(_)) = 0 // O record vai transformar a linha inteira em uma lista, para depois contarmos quantos itens dentro da linha ñ são nulos
            then 1 // Não tem nenhum dado na linha
            else 0 // Tem dados na linha  
    ),

    // Ordena os dados da coluna temporária para excluir mais rapidamente para agilizar o processo de exclusão das linhas que contém apenas valores nulos
    // Pensando em performance é melhor "trazer" as linhas que contém apenas valores nulos e ignorar (remover) do que ler uma a uma e depois ignorar
    organizarLinhasMantendoNulosAcima = Table.Buffer( // Salva na memória essa organização | É uma forma de garantir o Power Query NÃO tenha um Sort Folding (Esquecer a ordenação)
        Table.Sort( // Ordena os dados da tabela com base em uma condição
            adicionaColunaTemporariaParaOrdenarVazios, // Etapa anterior
            {
                {
                    "Linha Vazia", // Coluna que será ordenada
                    Order.Descending // Organiza o que tem resultado 1 primeiro e resultado 0 depois
                }
            }
        )
    ),

    // Nessa etapa o Skip "descarta" as linhas do topo enquanto a condição for 1.
    // Importante: Ordenamos os dados para agrupar o "lixo" no topo e acelerar a limpeza.
    ignorarLinhasComValoresNulos = Table.Skip( // Esse comando ñ retira linhas, mas ignora (PULA) as que ñ atendem a condição
        organizarLinhasMantendoNulosAcima, // Etapa anterior
        each [Linha Vazia] = 1 // Se o valor da linha é 1 deleta, se for 0 mantém
    ),

    // Removemos a coluna temporária para identificar as linhas com valores nulos
    removeColunaTemporariaParaOrdenarVazios = Table.RemoveColumns( // Remove colunas
        ignorarLinhasComValoresNulos, // Etapa anterior
        {"Linha Vazia"} // Coluna que será removida
    ),

    // Esta etapa força o Power Query a analisar o conteúdo de cada coluna 
    // e decidir o melhor tipo (Data, Número, Texto) de forma 100% dinâmica.
    definicaoDadosAutomatica = Table.TransformColumnTypes( 
        removeColunaTemporariaParaOrdenarVazios, // Etapa anterior 
        List.Transform( // Itera sobre cada uma das colunas
            Table.ColumnNames(removeColunaTemporariaParaOrdenarVazios), // Identifica o nome da coluna atual
            each // Aplica a cada linha
                let // Abre uma nova instancia

                    _valoresAmostra = List.FirstN( // Cria uma lista retornando os 5 primeiros valores da coluna 
                        Table.Column(removeColunaTemporariaParaOrdenarVazios, _), // Olha a etapa anterior e retorna o nome da coluna atual
                        5 // Aumentado para 5 para uma amostra mais segura
                    ),

                    _primeiroValorValido = List.First( // Retorna o primeiro valor ñ nulo como amostra
                        List.RemoveNulls(_valoresAmostra) // Com base na lista de valores de amostra remove os nulos
                    ), 
                        
                    _tipoIdentificado = 
                        if _primeiroValorValido = null then type text // Se for nulo retorna o tipo text (Vamos evitar que entre em todas as condições abaixo para melhorar o desempenho) 
                        else if Value.Type(_primeiroValorValido) <> type text then Value.Type(_primeiroValorValido) 
                        else 
                            let // Abre uma segunda instancia para isolar a lógica a seguir 
                                _texto = Text.From(_primeiroValorValido), // Converte o valor para texto
                                _tentarData = try Date.FromText(_texto) // Tenta converter o texto para data
                            in // Fecha a instancia que criamos para fazer a tentativa de conversão
                                if _tentarData[HasError] = false then type date // Se a tentativa de conversão em data ñ falhou, converte o valor em tipo data
                                else 
                                    let // Vamos repetir o processo, mas agora com tipo numérico
                                        _tentarNumero = try Number.FromText(_texto) // tenta converter em numero com virgula 
                                    in 
                                        if _tentarNumero[HasError] = false then type number // se ñ falhar converte em numero
                                        else type text // se falhou em converter em data ou numero retorna texto
                in // Fecha a ultima instancia
                    {_, _tipoIdentificado } // Atribui o tipo de dado a coluna
            )
        )
in
    // Retorna a tabela final com os tipos 
    definicaoDadosAutomatica
